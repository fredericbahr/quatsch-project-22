import { compareAsc } from "date-fns";
import {
  AnnotationTypes,
  CALCULATION_TYPE,
  defaultLUBWData,
  IFilteredAnnotations,
  ILUBWData,
  ILUBWDataKey,
  ILUBWDefaultData,
  ILUBWDefaultDataTime,
  IQanaryAnnotation,
  ITimeObject,
  REPRESENTATION_TYPE,
} from "shared";
/**
 * Service for transforming the annotations to the intermediate representation format.
 */
export class LUBWDataTransformationService {
  /**
   * Gets the transformed LUBW data from annotations.
   * @param annotations the qanary annotations generated by components
   * @param mergeWithDefaults whether the default values should be merged with the custom values
   * @returns transformed LUBW data
   */
  public static getTransformedLUBWData(
    annotations: Array<IQanaryAnnotation>,
    mergeWithDefaults = true,
  ): Partial<ILUBWData> {
    return this.transformAnnotationsToLUBWDataRepresentation(annotations, mergeWithDefaults);
  }

  /**
   * Transforms the annotations to the intermediate representation format
   * @param annotations the qanary annotations generated by components
   * @param mergeWithDefaults whether the default values should be merged with the custom values
   * @returns the intermediate representation format of the annotations
   */
  private static transformAnnotationsToLUBWDataRepresentation(
    annotations: Array<IQanaryAnnotation>,
    mergeWithDefaults: boolean,
  ): Partial<ILUBWData> {
    const filteredAnnotations: IFilteredAnnotations = this.filterAnnotations(annotations);

    return this.transformAndMergeWithDefaultLUBWData(filteredAnnotations, mergeWithDefaults);
  }

  /**
   * Transforms the annotations to the interim internal format and merges it with the default LUBW data.
   * @param filteredAnnotations the filtered annotations
   * @param mergeWithDefaults whether the default values should be merged with the custom values
   * @returns the interim internal format of the annotations
   */
  private static transformAndMergeWithDefaultLUBWData(
    filteredAnnotations: IFilteredAnnotations,
    mergeWithDefaults: boolean,
  ): Partial<ILUBWData> {
    const firstAnnotation = 0;

    const transformedValues: Partial<ILUBWData> = {
      station: filteredAnnotations.stationAnnotation[firstAnnotation]?.hasBody,
      measurand: filteredAnnotations.measurandAnnotation[firstAnnotation]?.hasBody,
      representation: filteredAnnotations.representationAnnotation[firstAnnotation]?.hasBody as REPRESENTATION_TYPE,
      calculation: filteredAnnotations.calculationAnnotation[firstAnnotation]?.hasBody as CALCULATION_TYPE,
      time: this.transformTime(filteredAnnotations.timeAnnotation[firstAnnotation]?.hasBody),
    };

    if (mergeWithDefaults) {
      return this.mergeWithDefaults(transformedValues, defaultLUBWData);
    }

    return transformedValues;
  }

  /**
   * Returns the earlier Date from two given dates
   * @param dateLeft Date to compare
   * @param dateRight Date to compare
   * @returns the early date of two
   */
  private static getEarlierDate(dateLeft: Date, dateRight: Date): Date {
    const compare = compareAsc(new Date(dateLeft), new Date(dateRight));
    if ([-1, 0].includes(compare)) {
      return dateLeft;
    }
    return dateRight;
  }

  /**
   * Transforms the time annotation to the interim internal format.
   * @param time the annotated time as serialized JSON
   * @returns the difference between the start and end date in days or undefined if the transformation failed
   */
  private static transformTime(time?: string): ILUBWDefaultDataTime | undefined {
    try {
      if (!time) {
        console.error("The time annotation is missing. Fallback to default value.");
        return undefined;
      }

      const timeObject: ITimeObject = JSON.parse(time) as ITimeObject;

      if (!timeObject.end) {
        return {
          ...defaultLUBWData[ILUBWDataKey.Time],
          start: this.getEarlierDate(new Date(timeObject.start), defaultLUBWData[ILUBWDataKey.Time].start),
        };
      }
      return {
        start: this.getEarlierDate(new Date(timeObject.start), defaultLUBWData[ILUBWDataKey.Time].start),
        end: this.getEarlierDate(new Date(timeObject.end), defaultLUBWData[ILUBWDataKey.Time].end),
      };
    } catch (error) {
      console.error(error);
      return defaultLUBWData[ILUBWDataKey.Time];
    }
  }

  /**
   * Sorts the dates ascending.
   * @param firstDateString the first date
   * @param secondDateString the second date
   * @returns an array with date strings sorted ascending
   */
  private static sortDates(firstDateString: string, secondDateString: string): string[] {
    const date1: number = new Date(firstDateString).getTime();
    const date2: number = new Date(secondDateString).getTime();

    if (date1 < date2) {
      return [firstDateString, secondDateString];
    }

    return [secondDateString, firstDateString];
  }

  /**
   * Merges the custom values with the default values, to ensure that all values that can be set via defualt are set.
   * @param customValues the custom values
   * @param defaultValues the default values
   * @returns the merged values
   */
  private static mergeWithDefaults(
    customValues: Partial<ILUBWData> | null,
    defaultValues: ILUBWDefaultData,
  ): Partial<ILUBWData> {
    customValues = customValues ?? {};
    return {
      ...customValues,
      representation: customValues.representation || defaultValues.representation,
      calculation: customValues.calculation || defaultValues.calculation,
      time: {
        ...defaultValues.time,
        ...customValues.time,
      },
    };
  }

  /**
   * Filters annotation by the domain instances and returns the filtered annotations for each instance.
   * @param annotations all annotations inside the qanary knowledge graph
   * @returns filtered annottions for each domain instance
   */
  private static filterAnnotations(annotations: Array<IQanaryAnnotation>): IFilteredAnnotations {
    const stationAnnotation: Array<IQanaryAnnotation> = annotations.filter((annotation) =>
      this.filterAnnotationsByAnnotationType(annotation, AnnotationTypes.Station),
    );

    const measurandAnnotation: Array<IQanaryAnnotation> = annotations.filter((annotation) =>
      this.filterAnnotationsByAnnotationType(annotation, AnnotationTypes.Measurand),
    );

    const representationAnnotation: Array<IQanaryAnnotation> = annotations.filter((annotation) =>
      this.filterAnnotationsByAnnotationType(annotation, AnnotationTypes.Representation),
    );

    const calculationAnnotation: Array<IQanaryAnnotation> = annotations.filter((annotation) =>
      this.filterAnnotationsByAnnotationType(annotation, AnnotationTypes.Calculation),
    );

    const timeAnnotation: Array<IQanaryAnnotation> = annotations.filter((annotation) =>
      this.filterAnnotationsByAnnotationType(annotation, AnnotationTypes.Time),
    );

    return {
      stationAnnotation,
      measurandAnnotation,
      representationAnnotation,
      calculationAnnotation,
      timeAnnotation,
    };
  }

  /**
   * Checks whether the given annotation is of annotation type.
   * @todo: TODO: change checking from producer to annotation type
   * @param annotation the annotation to check
   * @param annotationType the type to match
   * @returns true if annotation is of annotation type, false otherwise
   */
  private static filterAnnotationsByAnnotationType(annotation: IQanaryAnnotation, annotationType: string): boolean {
    return annotation.annotationType.includes(annotationType);
  }
}
