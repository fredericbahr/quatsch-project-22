/* tslint:disable */
/* eslint-disable */
/**
 * MyQanaryPipeline
 * Provides central functionality for each Qanary component (registration) and endpoints for users.
 *
 * The version of the OpenAPI document: 1.6.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AdditionalTriples
 */
export interface AdditionalTriples {
    /**
     * 
     * @type {string}
     * @memberof AdditionalTriples
     */
    'stringFilePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdditionalTriples
     */
    'uuidstring'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdditionalTriples
     */
    'uriFilePath'?: string;
}
/**
 * 
 * @export
 * @interface CreateQuestionAnsweringFullRequest
 */
export interface CreateQuestionAnsweringFullRequest {
    /**
     * 
     * @type {File}
     * @memberof CreateQuestionAnsweringFullRequest
     */
    'audioquestion'?: File;
}
/**
 * 
 * @export
 * @interface GerbilExecuteResponse
 */
export interface GerbilExecuteResponse {
    /**
     * 
     * @type {Array<Question>}
     * @memberof GerbilExecuteResponse
     */
    'questions'?: Array<Question>;
}
/**
 * 
 * @export
 * @interface NumberOfAnnotationsResponse
 */
export interface NumberOfAnnotationsResponse {
    /**
     * 
     * @type {string}
     * @memberof NumberOfAnnotationsResponse
     */
    'componentUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof NumberOfAnnotationsResponse
     */
    'annotationCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof NumberOfAnnotationsResponse
     */
    'graph'?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberOfAnnotationsResponse
     */
    'sparqlGet'?: string;
}
/**
 * 
 * @export
 * @interface QanaryAvailableQuestions
 */
export interface QanaryAvailableQuestions {
    /**
     * 
     * @type {Array<string>}
     * @memberof QanaryAvailableQuestions
     */
    'availableQuestions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface QanaryQuestionInformation
 */
export interface QanaryQuestionInformation {
    /**
     * 
     * @type {string}
     * @memberof QanaryQuestionInformation
     */
    'rawdata'?: string;
    /**
     * 
     * @type {string}
     * @memberof QanaryQuestionInformation
     */
    'questionID'?: string;
}
/**
 * 
 * @export
 * @interface QueryObj
 */
export interface QueryObj {
    /**
     * 
     * @type {string}
     * @memberof QueryObj
     */
    'sparql'?: string;
}
/**
 * 
 * @export
 * @interface Question
 */
export interface Question {
    /**
     * 
     * @type {Array<QuestionData>}
     * @memberof Question
     */
    'question'?: Array<QuestionData>;
    /**
     * 
     * @type {QueryObj}
     * @memberof Question
     */
    'query'?: QueryObj;
    /**
     * 
     * @type {Array<object>}
     * @memberof Question
     */
    'answers'?: Array<object>;
}
/**
 * 
 * @export
 * @interface QuestionData
 */
export interface QuestionData {
    /**
     * 
     * @type {string}
     * @memberof QuestionData
     */
    'string'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionData
     */
    'language'?: string;
}
/**
 * 
 * @export
 * @interface RequestQuestionAnsweringProcess
 */
export interface RequestQuestionAnsweringProcess {
    /**
     * 
     * @type {string}
     * @memberof RequestQuestionAnsweringProcess
     */
    'question'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestQuestionAnsweringProcess
     */
    'getcomponentlist'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RequestQuestionAnsweringProcess
     */
    'language'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestQuestionAnsweringProcess
     */
    'targetdata'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RequestQuestionAnsweringProcess
     */
    'priorConversation'?: string;
}
/**
 * 
 * @export
 * @interface Result
 */
export interface Result {
    /**
     * 
     * @type {string}
     * @memberof Result
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StartquestionansweringwithaudioquestionRequest
 */
export interface StartquestionansweringwithaudioquestionRequest {
    /**
     * 
     * @type {File}
     * @memberof StartquestionansweringwithaudioquestionRequest
     */
    'question': File;
}

/**
 * QanaryComponentsManagementControllerApi - axios parameter creator
 * @export
 */
export const QanaryComponentsManagementControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} componentName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDescriptionOfComponentAsJsonLD: async (componentName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'componentName' is not null or undefined
            assertParamExists('getServiceDescriptionOfComponentAsJsonLD', 'componentName', componentName)
            const localVarPath = `/components/{componentName}`
                .replace(`{${"componentName"}}`, encodeURIComponent(String(componentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanaryComponentsManagementControllerApi - functional programming interface
 * @export
 */
export const QanaryComponentsManagementControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanaryComponentsManagementControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} componentName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDescriptionOfComponentAsJsonLD(componentName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDescriptionOfComponentAsJsonLD(componentName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanaryComponentsManagementControllerApi - factory interface
 * @export
 */
export const QanaryComponentsManagementControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanaryComponentsManagementControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} componentName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDescriptionOfComponentAsJsonLD(componentName: string, options?: any): AxiosPromise<string> {
            return localVarFp.getServiceDescriptionOfComponentAsJsonLD(componentName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanaryComponentsManagementControllerApi - object-oriented interface
 * @export
 * @class QanaryComponentsManagementControllerApi
 * @extends {BaseAPI}
 */
export class QanaryComponentsManagementControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} componentName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryComponentsManagementControllerApi
     */
    public getServiceDescriptionOfComponentAsJsonLD(componentName: string, options?: AxiosRequestConfig) {
        return QanaryComponentsManagementControllerApiFp(this.configuration).getServiceDescriptionOfComponentAsJsonLD(componentName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QanaryConfigurationControllerApi - axios parameter creator
 * @export
 */
export const QanaryConfigurationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of registered and available components, containing their name and url.
         * @summary get a list of all registered components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableComponents: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/components`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanaryConfigurationControllerApi - functional programming interface
 * @export
 */
export const QanaryConfigurationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanaryConfigurationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of registered and available components, containing their name and url.
         * @summary get a list of all registered components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableComponents(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableComponents(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanaryConfigurationControllerApi - factory interface
 * @export
 */
export const QanaryConfigurationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanaryConfigurationControllerApiFp(configuration)
    return {
        /**
         * Returns a list of registered and available components, containing their name and url.
         * @summary get a list of all registered components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableComponents(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getAvailableComponents(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanaryConfigurationControllerApi - object-oriented interface
 * @export
 * @class QanaryConfigurationControllerApi
 * @extends {BaseAPI}
 */
export class QanaryConfigurationControllerApi extends BaseAPI {
    /**
     * Returns a list of registered and available components, containing their name and url.
     * @summary get a list of all registered components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryConfigurationControllerApi
     */
    public getAvailableComponents(options?: AxiosRequestConfig) {
        return QanaryConfigurationControllerApiFp(this.configuration).getAvailableComponents(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QanaryEmbeddedQaWebFrontendControllerApi - axios parameter creator
 * @export
 */
export const QanaryEmbeddedQaWebFrontendControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use the qanary.componentList defined in local properties file. Example: curl -d question=\'Capital of France?\' http://localhost:8080/qa
         * @summary start a pre-configured question answering process
         * @param {string} question 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qa: async (question: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'question' is not null or undefined
            assertParamExists('qa', 'question', question)
            const localVarPath = `/qa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (question !== undefined) {
                localVarQueryParameter['question'] = question;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanaryEmbeddedQaWebFrontendControllerApi - functional programming interface
 * @export
 */
export const QanaryEmbeddedQaWebFrontendControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanaryEmbeddedQaWebFrontendControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Use the qanary.componentList defined in local properties file. Example: curl -d question=\'Capital of France?\' http://localhost:8080/qa
         * @summary start a pre-configured question answering process
         * @param {string} question 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qa(question: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qa(question, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanaryEmbeddedQaWebFrontendControllerApi - factory interface
 * @export
 */
export const QanaryEmbeddedQaWebFrontendControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanaryEmbeddedQaWebFrontendControllerApiFp(configuration)
    return {
        /**
         * Use the qanary.componentList defined in local properties file. Example: curl -d question=\'Capital of France?\' http://localhost:8080/qa
         * @summary start a pre-configured question answering process
         * @param {string} question 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qa(question: string, options?: any): AxiosPromise<string> {
            return localVarFp.qa(question, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanaryEmbeddedQaWebFrontendControllerApi - object-oriented interface
 * @export
 * @class QanaryEmbeddedQaWebFrontendControllerApi
 * @extends {BaseAPI}
 */
export class QanaryEmbeddedQaWebFrontendControllerApi extends BaseAPI {
    /**
     * Use the qanary.componentList defined in local properties file. Example: curl -d question=\'Capital of France?\' http://localhost:8080/qa
     * @summary start a pre-configured question answering process
     * @param {string} question 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryEmbeddedQaWebFrontendControllerApi
     */
    public qa(question: string, options?: AxiosRequestConfig) {
        return QanaryEmbeddedQaWebFrontendControllerApiFp(this.configuration).qa(question, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QanaryFeedbackControllerApi - axios parameter creator
 * @export
 */
export const QanaryFeedbackControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} question 
         * @param {string} sparql 
         * @param {boolean} correct 
         * @param {string} [language] 
         * @param {string} [knowledgebase] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithtextquestion: async (question: string, sparql: string, correct: boolean, language?: string, knowledgebase?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'question' is not null or undefined
            assertParamExists('startquestionansweringwithtextquestion', 'question', question)
            // verify required parameter 'sparql' is not null or undefined
            assertParamExists('startquestionansweringwithtextquestion', 'sparql', sparql)
            // verify required parameter 'correct' is not null or undefined
            assertParamExists('startquestionansweringwithtextquestion', 'correct', correct)
            const localVarPath = `/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (question !== undefined) {
                localVarQueryParameter['question'] = question;
            }

            if (sparql !== undefined) {
                localVarQueryParameter['sparql'] = sparql;
            }

            if (correct !== undefined) {
                localVarQueryParameter['correct'] = correct;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (knowledgebase !== undefined) {
                localVarQueryParameter['knowledgebase'] = knowledgebase;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanaryFeedbackControllerApi - functional programming interface
 * @export
 */
export const QanaryFeedbackControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanaryFeedbackControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} question 
         * @param {string} sparql 
         * @param {boolean} correct 
         * @param {string} [language] 
         * @param {string} [knowledgebase] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startquestionansweringwithtextquestion(question: string, sparql: string, correct: boolean, language?: string, knowledgebase?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startquestionansweringwithtextquestion(question, sparql, correct, language, knowledgebase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanaryFeedbackControllerApi - factory interface
 * @export
 */
export const QanaryFeedbackControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanaryFeedbackControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} question 
         * @param {string} sparql 
         * @param {boolean} correct 
         * @param {string} [language] 
         * @param {string} [knowledgebase] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithtextquestion(question: string, sparql: string, correct: boolean, language?: string, knowledgebase?: string, options?: any): AxiosPromise<object> {
            return localVarFp.startquestionansweringwithtextquestion(question, sparql, correct, language, knowledgebase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanaryFeedbackControllerApi - object-oriented interface
 * @export
 * @class QanaryFeedbackControllerApi
 * @extends {BaseAPI}
 */
export class QanaryFeedbackControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} question 
     * @param {string} sparql 
     * @param {boolean} correct 
     * @param {string} [language] 
     * @param {string} [knowledgebase] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryFeedbackControllerApi
     */
    public startquestionansweringwithtextquestion(question: string, sparql: string, correct: boolean, language?: string, knowledgebase?: string, options?: AxiosRequestConfig) {
        return QanaryFeedbackControllerApiFp(this.configuration).startquestionansweringwithtextquestion(question, sparql, correct, language, knowledgebase, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QanaryGerbilControllerApi - axios parameter creator
 * @export
 */
export const QanaryGerbilControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * examples: curl -X POST http://localhost:8080/gerbil-execute/QAnswerQueryBuilderAndExecutor -d query=\'What is the capital of France?\'  or curl -X POST http://localhost:8080/gerbil-execute/NED-DBpediaSpotlight -d query=\'What is the capital of France?\'
         * @summary Start a Gerbil QA process with a list of components
         * @param {string} query 
         * @param {string} components 
         * @param {string} [lang] 
         * @param {string} [priorConversation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gerbil: async (query: string, components: string, lang?: string, priorConversation?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('gerbil', 'query', query)
            // verify required parameter 'components' is not null or undefined
            assertParamExists('gerbil', 'components', components)
            const localVarPath = `/gerbil-execute/{components}`
                .replace(`{${"components"}}`, encodeURIComponent(String(components)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (priorConversation !== undefined) {
                localVarQueryParameter['priorConversation'] = priorConversation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a URL endpoint for Gerbil QA from a list of compoents.
         * @summary expose an HTML frontend for a Gerbil URL endpoint
         * @param {Array<string>} [componentlist] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gerbilGenerator: async (componentlist?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gerbil`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (componentlist) {
                localVarQueryParameter['componentlist[]'] = componentlist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a URL endpoint for Gerbil for QA (http://gerbil-qa.aksw.org/gerbil/config) through a simple HTML input form.
         * @summary expose an HTML frontend for generating a Gerbil URL endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithtextquestion2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gerbil`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanaryGerbilControllerApi - functional programming interface
 * @export
 */
export const QanaryGerbilControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanaryGerbilControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * examples: curl -X POST http://localhost:8080/gerbil-execute/QAnswerQueryBuilderAndExecutor -d query=\'What is the capital of France?\'  or curl -X POST http://localhost:8080/gerbil-execute/NED-DBpediaSpotlight -d query=\'What is the capital of France?\'
         * @summary Start a Gerbil QA process with a list of components
         * @param {string} query 
         * @param {string} components 
         * @param {string} [lang] 
         * @param {string} [priorConversation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gerbil(query: string, components: string, lang?: string, priorConversation?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GerbilExecuteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gerbil(query, components, lang, priorConversation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a URL endpoint for Gerbil QA from a list of compoents.
         * @summary expose an HTML frontend for a Gerbil URL endpoint
         * @param {Array<string>} [componentlist] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gerbilGenerator(componentlist?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gerbilGenerator(componentlist, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a URL endpoint for Gerbil for QA (http://gerbil-qa.aksw.org/gerbil/config) through a simple HTML input form.
         * @summary expose an HTML frontend for generating a Gerbil URL endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startquestionansweringwithtextquestion2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startquestionansweringwithtextquestion2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanaryGerbilControllerApi - factory interface
 * @export
 */
export const QanaryGerbilControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanaryGerbilControllerApiFp(configuration)
    return {
        /**
         * examples: curl -X POST http://localhost:8080/gerbil-execute/QAnswerQueryBuilderAndExecutor -d query=\'What is the capital of France?\'  or curl -X POST http://localhost:8080/gerbil-execute/NED-DBpediaSpotlight -d query=\'What is the capital of France?\'
         * @summary Start a Gerbil QA process with a list of components
         * @param {string} query 
         * @param {string} components 
         * @param {string} [lang] 
         * @param {string} [priorConversation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gerbil(query: string, components: string, lang?: string, priorConversation?: string, options?: any): AxiosPromise<GerbilExecuteResponse> {
            return localVarFp.gerbil(query, components, lang, priorConversation, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a URL endpoint for Gerbil QA from a list of compoents.
         * @summary expose an HTML frontend for a Gerbil URL endpoint
         * @param {Array<string>} [componentlist] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gerbilGenerator(componentlist?: Array<string>, options?: any): AxiosPromise<string> {
            return localVarFp.gerbilGenerator(componentlist, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a URL endpoint for Gerbil for QA (http://gerbil-qa.aksw.org/gerbil/config) through a simple HTML input form.
         * @summary expose an HTML frontend for generating a Gerbil URL endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithtextquestion2(options?: any): AxiosPromise<string> {
            return localVarFp.startquestionansweringwithtextquestion2(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanaryGerbilControllerApi - object-oriented interface
 * @export
 * @class QanaryGerbilControllerApi
 * @extends {BaseAPI}
 */
export class QanaryGerbilControllerApi extends BaseAPI {
    /**
     * examples: curl -X POST http://localhost:8080/gerbil-execute/QAnswerQueryBuilderAndExecutor -d query=\'What is the capital of France?\'  or curl -X POST http://localhost:8080/gerbil-execute/NED-DBpediaSpotlight -d query=\'What is the capital of France?\'
     * @summary Start a Gerbil QA process with a list of components
     * @param {string} query 
     * @param {string} components 
     * @param {string} [lang] 
     * @param {string} [priorConversation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryGerbilControllerApi
     */
    public gerbil(query: string, components: string, lang?: string, priorConversation?: string, options?: AxiosRequestConfig) {
        return QanaryGerbilControllerApiFp(this.configuration).gerbil(query, components, lang, priorConversation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a URL endpoint for Gerbil QA from a list of compoents.
     * @summary expose an HTML frontend for a Gerbil URL endpoint
     * @param {Array<string>} [componentlist] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryGerbilControllerApi
     */
    public gerbilGenerator(componentlist?: Array<string>, options?: AxiosRequestConfig) {
        return QanaryGerbilControllerApiFp(this.configuration).gerbilGenerator(componentlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a URL endpoint for Gerbil for QA (http://gerbil-qa.aksw.org/gerbil/config) through a simple HTML input form.
     * @summary expose an HTML frontend for generating a Gerbil URL endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryGerbilControllerApi
     */
    public startquestionansweringwithtextquestion2(options?: AxiosRequestConfig) {
        return QanaryGerbilControllerApiFp(this.configuration).startquestionansweringwithtextquestion2(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QanaryPipelineConfigurationControllerApi - axios parameter creator
 * @export
 */
export const QanaryPipelineConfigurationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurablePipelineProperties: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocalPipelineProperties: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateLocalPipelineProperties', 'body', body)
            const localVarPath = `/configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanaryPipelineConfigurationControllerApi - functional programming interface
 * @export
 */
export const QanaryPipelineConfigurationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanaryPipelineConfigurationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigurablePipelineProperties(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigurablePipelineProperties(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLocalPipelineProperties(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLocalPipelineProperties(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanaryPipelineConfigurationControllerApi - factory interface
 * @export
 */
export const QanaryPipelineConfigurationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanaryPipelineConfigurationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurablePipelineProperties(options?: any): AxiosPromise<object> {
            return localVarFp.getConfigurablePipelineProperties(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocalPipelineProperties(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.updateLocalPipelineProperties(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanaryPipelineConfigurationControllerApi - object-oriented interface
 * @export
 * @class QanaryPipelineConfigurationControllerApi
 * @extends {BaseAPI}
 */
export class QanaryPipelineConfigurationControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryPipelineConfigurationControllerApi
     */
    public getConfigurablePipelineProperties(options?: AxiosRequestConfig) {
        return QanaryPipelineConfigurationControllerApiFp(this.configuration).getConfigurablePipelineProperties(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryPipelineConfigurationControllerApi
     */
    public updateLocalPipelineProperties(body: object, options?: AxiosRequestConfig) {
        return QanaryPipelineConfigurationControllerApiFp(this.configuration).updateLocalPipelineProperties(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QanaryQuestionAnsweringControllerApi - axios parameter creator
 * @export
 */
export const QanaryQuestionAnsweringControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (not yet implemented) The run is identified by the provided runId
         * @summary Update information about a specific question answering run
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateQuestionAnsweringGraph: async (runId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('createOrUpdateQuestionAnsweringGraph', 'runId', runId)
            const localVarPath = `/questionanswering/{runId}`
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * No parameters are required.
         * @summary Create a new Question Answering Process
         * @param {string} [textquestion] 
         * @param {string} [graph] 
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {CreateQuestionAnsweringFullRequest} [createQuestionAnsweringFullRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionAnswering: async (textquestion?: string, graph?: string, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, createQuestionAnsweringFullRequest?: CreateQuestionAnsweringFullRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questionanswering`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (textquestion !== undefined) {
                localVarQueryParameter['textquestion'] = textquestion;
            }

            if (graph !== undefined) {
                localVarQueryParameter['graph'] = graph;
            }

            if (componentlist) {
                localVarQueryParameter['componentlist[]'] = componentlist;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (targetdata) {
                localVarQueryParameter['targetdata'] = targetdata;
            }

            if (priorConversation !== undefined) {
                localVarQueryParameter['priorConversation'] = priorConversation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQuestionAnsweringFullRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * No parameters are required.
         * @summary Create a new Question Answering Process
         * @param {string} [textquestion] 
         * @param {string} [graph] 
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {CreateQuestionAnsweringFullRequest} [createQuestionAnsweringFullRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionAnsweringFull: async (textquestion?: string, graph?: string, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, createQuestionAnsweringFullRequest?: CreateQuestionAnsweringFullRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questionansweringfull`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (textquestion !== undefined) {
                localVarQueryParameter['textquestion'] = textquestion;
            }

            if (graph !== undefined) {
                localVarQueryParameter['graph'] = graph;
            }

            if (componentlist) {
                localVarQueryParameter['componentlist[]'] = componentlist;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (targetdata) {
                localVarQueryParameter['targetdata'] = targetdata;
            }

            if (priorConversation !== undefined) {
                localVarQueryParameter['priorConversation'] = priorConversation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQuestionAnsweringFullRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (not yet implemented) The run is identified by the provided runId
         * @summary Delete information about a specific question answering run
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionAnsweringGraph: async (runId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('deleteQuestionAnsweringGraph', 'runId', runId)
            const localVarPath = `/questionanswering/{runId}`
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View additional triples that were passed and stored when starting the question answering process. Requires a valid ID.
         * @summary Expose additonal Triples
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalTriples: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAdditionalTriples', 'id', id)
            const localVarPath = `/additional-triples/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View or download the Open Annotation Data Model.
         * @summary Expose the OA commons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oa.owl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View or download the Qanary ontology.
         * @summary Expose the Qanary ontology
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/qanaryOntology.ttl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter all annotations created for the current question answering run to find how many were created by a specific component. Requires the correct component name (case sensitive) and the graph.
         * @summary Get the number of annotations created by a component
         * @param {string} component 
         * @param {string} graph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNumberOfAnnotationsForComponent: async (component: string, graph: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'component' is not null or undefined
            assertParamExists('getNumberOfAnnotationsForComponent', 'component', component)
            // verify required parameter 'graph' is not null or undefined
            assertParamExists('getNumberOfAnnotationsForComponent', 'graph', graph)
            const localVarPath = `/numberOfAnnotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }

            if (graph !== undefined) {
                localVarQueryParameter['graph'] = graph;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (not yet implemented) The run is identified by the provided runId
         * @summary Return information about a specific question answering run
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionAnsweringGraphInformation: async (runId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getQuestionAnsweringGraphInformation', 'runId', runId)
            const localVarPath = `/questionanswering/{runId}`
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only the audio question is required. Examples: t.b.a
         * @summary Start a process directly with an audio question
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {StartquestionansweringwithaudioquestionRequest} [startquestionansweringwithaudioquestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithaudioquestion: async (componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, startquestionansweringwithaudioquestionRequest?: StartquestionansweringwithaudioquestionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/startquestionansweringwithaudioquestion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (componentlist) {
                localVarQueryParameter['componentlist[]'] = componentlist;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (targetdata) {
                localVarQueryParameter['targetdata'] = targetdata;
            }

            if (priorConversation !== undefined) {
                localVarQueryParameter['priorConversation'] = priorConversation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startquestionansweringwithaudioquestionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a simple HTML form for starting a question answering process with an audio question
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithaudioquestion1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/startquestionansweringwithaudioquestion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a simple HTML input form for starting a question answering process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithtextquestion1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/startquestionansweringwithtextquestion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Parameters are supplied via JSON. Only the question parameter is required. Examples: {\"question\": \"What is the capital of Germany?\"}, {\"question\": \"Person born in France?\"}
         * @summary Start a process directly with a textual question
         * @param {string} question 
         * @param {RequestQuestionAnsweringProcess} requestQuestionAnsweringProcess 
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {AdditionalTriples} [additionaltriples] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        startquestionansweringwithtextquestion11: async (question: string, requestQuestionAnsweringProcess: RequestQuestionAnsweringProcess, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, additionaltriples?: AdditionalTriples, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'question' is not null or undefined
            assertParamExists('startquestionansweringwithtextquestion11', 'question', question)
            // verify required parameter 'requestQuestionAnsweringProcess' is not null or undefined
            assertParamExists('startquestionansweringwithtextquestion11', 'requestQuestionAnsweringProcess', requestQuestionAnsweringProcess)
            const localVarPath = `/startquestionansweringwithtextquestion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (question !== undefined) {
                localVarQueryParameter['question'] = question;
            }

            if (componentlist) {
                localVarQueryParameter['componentlist[]'] = componentlist;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (targetdata) {
                localVarQueryParameter['targetdata'] = targetdata;
            }

            if (priorConversation !== undefined) {
                localVarQueryParameter['priorConversation'] = priorConversation;
            }

            if (additionaltriples !== undefined) {
                localVarQueryParameter['additionaltriples'] = additionaltriples;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestQuestionAnsweringProcess, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanaryQuestionAnsweringControllerApi - functional programming interface
 * @export
 */
export const QanaryQuestionAnsweringControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanaryQuestionAnsweringControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * (not yet implemented) The run is identified by the provided runId
         * @summary Update information about a specific question answering run
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateQuestionAnsweringGraph(runId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateQuestionAnsweringGraph(runId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * No parameters are required.
         * @summary Create a new Question Answering Process
         * @param {string} [textquestion] 
         * @param {string} [graph] 
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {CreateQuestionAnsweringFullRequest} [createQuestionAnsweringFullRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestionAnswering(textquestion?: string, graph?: string, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, createQuestionAnsweringFullRequest?: CreateQuestionAnsweringFullRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestionAnswering(textquestion, graph, componentlist, language, targetdata, priorConversation, createQuestionAnsweringFullRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * No parameters are required.
         * @summary Create a new Question Answering Process
         * @param {string} [textquestion] 
         * @param {string} [graph] 
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {CreateQuestionAnsweringFullRequest} [createQuestionAnsweringFullRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestionAnsweringFull(textquestion?: string, graph?: string, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, createQuestionAnsweringFullRequest?: CreateQuestionAnsweringFullRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestionAnsweringFull(textquestion, graph, componentlist, language, targetdata, priorConversation, createQuestionAnsweringFullRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (not yet implemented) The run is identified by the provided runId
         * @summary Delete information about a specific question answering run
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestionAnsweringGraph(runId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuestionAnsweringGraph(runId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View additional triples that were passed and stored when starting the question answering process. Requires a valid ID.
         * @summary Expose additonal Triples
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdditionalTriples(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdditionalTriples(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View or download the Open Annotation Data Model.
         * @summary Expose the OA commons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View or download the Qanary ontology.
         * @summary Expose the Qanary ontology
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Filter all annotations created for the current question answering run to find how many were created by a specific component. Requires the correct component name (case sensitive) and the graph.
         * @summary Get the number of annotations created by a component
         * @param {string} component 
         * @param {string} graph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNumberOfAnnotationsForComponent(component: string, graph: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NumberOfAnnotationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNumberOfAnnotationsForComponent(component, graph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (not yet implemented) The run is identified by the provided runId
         * @summary Return information about a specific question answering run
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionAnsweringGraphInformation(runId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionAnsweringGraphInformation(runId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only the audio question is required. Examples: t.b.a
         * @summary Start a process directly with an audio question
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {StartquestionansweringwithaudioquestionRequest} [startquestionansweringwithaudioquestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startquestionansweringwithaudioquestion(componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, startquestionansweringwithaudioquestionRequest?: StartquestionansweringwithaudioquestionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startquestionansweringwithaudioquestion(componentlist, language, targetdata, priorConversation, startquestionansweringwithaudioquestionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a simple HTML form for starting a question answering process with an audio question
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startquestionansweringwithaudioquestion1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startquestionansweringwithaudioquestion1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a simple HTML input form for starting a question answering process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startquestionansweringwithtextquestion1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startquestionansweringwithtextquestion1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Parameters are supplied via JSON. Only the question parameter is required. Examples: {\"question\": \"What is the capital of Germany?\"}, {\"question\": \"Person born in France?\"}
         * @summary Start a process directly with a textual question
         * @param {string} question 
         * @param {RequestQuestionAnsweringProcess} requestQuestionAnsweringProcess 
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {AdditionalTriples} [additionaltriples] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async startquestionansweringwithtextquestion11(question: string, requestQuestionAnsweringProcess: RequestQuestionAnsweringProcess, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, additionaltriples?: AdditionalTriples, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startquestionansweringwithtextquestion11(question, requestQuestionAnsweringProcess, componentlist, language, targetdata, priorConversation, additionaltriples, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanaryQuestionAnsweringControllerApi - factory interface
 * @export
 */
export const QanaryQuestionAnsweringControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanaryQuestionAnsweringControllerApiFp(configuration)
    return {
        /**
         * (not yet implemented) The run is identified by the provided runId
         * @summary Update information about a specific question answering run
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateQuestionAnsweringGraph(runId: string, options?: any): AxiosPromise<object> {
            return localVarFp.createOrUpdateQuestionAnsweringGraph(runId, options).then((request) => request(axios, basePath));
        },
        /**
         * No parameters are required.
         * @summary Create a new Question Answering Process
         * @param {string} [textquestion] 
         * @param {string} [graph] 
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {CreateQuestionAnsweringFullRequest} [createQuestionAnsweringFullRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionAnswering(textquestion?: string, graph?: string, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, createQuestionAnsweringFullRequest?: CreateQuestionAnsweringFullRequest, options?: any): AxiosPromise<object> {
            return localVarFp.createQuestionAnswering(textquestion, graph, componentlist, language, targetdata, priorConversation, createQuestionAnsweringFullRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * No parameters are required.
         * @summary Create a new Question Answering Process
         * @param {string} [textquestion] 
         * @param {string} [graph] 
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {CreateQuestionAnsweringFullRequest} [createQuestionAnsweringFullRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionAnsweringFull(textquestion?: string, graph?: string, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, createQuestionAnsweringFullRequest?: CreateQuestionAnsweringFullRequest, options?: any): AxiosPromise<object> {
            return localVarFp.createQuestionAnsweringFull(textquestion, graph, componentlist, language, targetdata, priorConversation, createQuestionAnsweringFullRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * (not yet implemented) The run is identified by the provided runId
         * @summary Delete information about a specific question answering run
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionAnsweringGraph(runId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteQuestionAnsweringGraph(runId, options).then((request) => request(axios, basePath));
        },
        /**
         * View additional triples that were passed and stored when starting the question answering process. Requires a valid ID.
         * @summary Expose additonal Triples
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalTriples(id: string, options?: any): AxiosPromise<File> {
            return localVarFp.getAdditionalTriples(id, options).then((request) => request(axios, basePath));
        },
        /**
         * View or download the Open Annotation Data Model.
         * @summary Expose the OA commons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile1(options?: any): AxiosPromise<File> {
            return localVarFp.getFile1(options).then((request) => request(axios, basePath));
        },
        /**
         * View or download the Qanary ontology.
         * @summary Expose the Qanary ontology
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile2(options?: any): AxiosPromise<File> {
            return localVarFp.getFile2(options).then((request) => request(axios, basePath));
        },
        /**
         * Filter all annotations created for the current question answering run to find how many were created by a specific component. Requires the correct component name (case sensitive) and the graph.
         * @summary Get the number of annotations created by a component
         * @param {string} component 
         * @param {string} graph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNumberOfAnnotationsForComponent(component: string, graph: string, options?: any): AxiosPromise<NumberOfAnnotationsResponse> {
            return localVarFp.getNumberOfAnnotationsForComponent(component, graph, options).then((request) => request(axios, basePath));
        },
        /**
         * (not yet implemented) The run is identified by the provided runId
         * @summary Return information about a specific question answering run
         * @param {string} runId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionAnsweringGraphInformation(runId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getQuestionAnsweringGraphInformation(runId, options).then((request) => request(axios, basePath));
        },
        /**
         * Only the audio question is required. Examples: t.b.a
         * @summary Start a process directly with an audio question
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {StartquestionansweringwithaudioquestionRequest} [startquestionansweringwithaudioquestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithaudioquestion(componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, startquestionansweringwithaudioquestionRequest?: StartquestionansweringwithaudioquestionRequest, options?: any): AxiosPromise<object> {
            return localVarFp.startquestionansweringwithaudioquestion(componentlist, language, targetdata, priorConversation, startquestionansweringwithaudioquestionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a simple HTML form for starting a question answering process with an audio question
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithaudioquestion1(options?: any): AxiosPromise<string> {
            return localVarFp.startquestionansweringwithaudioquestion1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a simple HTML input form for starting a question answering process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startquestionansweringwithtextquestion1(options?: any): AxiosPromise<string> {
            return localVarFp.startquestionansweringwithtextquestion1(options).then((request) => request(axios, basePath));
        },
        /**
         * Parameters are supplied via JSON. Only the question parameter is required. Examples: {\"question\": \"What is the capital of Germany?\"}, {\"question\": \"Person born in France?\"}
         * @summary Start a process directly with a textual question
         * @param {string} question 
         * @param {RequestQuestionAnsweringProcess} requestQuestionAnsweringProcess 
         * @param {Array<string>} [componentlist] 
         * @param {string} [language] 
         * @param {Array<string>} [targetdata] 
         * @param {string} [priorConversation] 
         * @param {AdditionalTriples} [additionaltriples] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        startquestionansweringwithtextquestion11(question: string, requestQuestionAnsweringProcess: RequestQuestionAnsweringProcess, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, additionaltriples?: AdditionalTriples, options?: any): AxiosPromise<object> {
            return localVarFp.startquestionansweringwithtextquestion11(question, requestQuestionAnsweringProcess, componentlist, language, targetdata, priorConversation, additionaltriples, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanaryQuestionAnsweringControllerApi - object-oriented interface
 * @export
 * @class QanaryQuestionAnsweringControllerApi
 * @extends {BaseAPI}
 */
export class QanaryQuestionAnsweringControllerApi extends BaseAPI {
    /**
     * (not yet implemented) The run is identified by the provided runId
     * @summary Update information about a specific question answering run
     * @param {string} runId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public createOrUpdateQuestionAnsweringGraph(runId: string, options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).createOrUpdateQuestionAnsweringGraph(runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * No parameters are required.
     * @summary Create a new Question Answering Process
     * @param {string} [textquestion] 
     * @param {string} [graph] 
     * @param {Array<string>} [componentlist] 
     * @param {string} [language] 
     * @param {Array<string>} [targetdata] 
     * @param {string} [priorConversation] 
     * @param {CreateQuestionAnsweringFullRequest} [createQuestionAnsweringFullRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public createQuestionAnswering(textquestion?: string, graph?: string, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, createQuestionAnsweringFullRequest?: CreateQuestionAnsweringFullRequest, options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).createQuestionAnswering(textquestion, graph, componentlist, language, targetdata, priorConversation, createQuestionAnsweringFullRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * No parameters are required.
     * @summary Create a new Question Answering Process
     * @param {string} [textquestion] 
     * @param {string} [graph] 
     * @param {Array<string>} [componentlist] 
     * @param {string} [language] 
     * @param {Array<string>} [targetdata] 
     * @param {string} [priorConversation] 
     * @param {CreateQuestionAnsweringFullRequest} [createQuestionAnsweringFullRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public createQuestionAnsweringFull(textquestion?: string, graph?: string, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, createQuestionAnsweringFullRequest?: CreateQuestionAnsweringFullRequest, options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).createQuestionAnsweringFull(textquestion, graph, componentlist, language, targetdata, priorConversation, createQuestionAnsweringFullRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (not yet implemented) The run is identified by the provided runId
     * @summary Delete information about a specific question answering run
     * @param {string} runId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public deleteQuestionAnsweringGraph(runId: string, options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).deleteQuestionAnsweringGraph(runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View additional triples that were passed and stored when starting the question answering process. Requires a valid ID.
     * @summary Expose additonal Triples
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public getAdditionalTriples(id: string, options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).getAdditionalTriples(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View or download the Open Annotation Data Model.
     * @summary Expose the OA commons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public getFile1(options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).getFile1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View or download the Qanary ontology.
     * @summary Expose the Qanary ontology
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public getFile2(options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).getFile2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter all annotations created for the current question answering run to find how many were created by a specific component. Requires the correct component name (case sensitive) and the graph.
     * @summary Get the number of annotations created by a component
     * @param {string} component 
     * @param {string} graph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public getNumberOfAnnotationsForComponent(component: string, graph: string, options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).getNumberOfAnnotationsForComponent(component, graph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (not yet implemented) The run is identified by the provided runId
     * @summary Return information about a specific question answering run
     * @param {string} runId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public getQuestionAnsweringGraphInformation(runId: string, options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).getQuestionAnsweringGraphInformation(runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only the audio question is required. Examples: t.b.a
     * @summary Start a process directly with an audio question
     * @param {Array<string>} [componentlist] 
     * @param {string} [language] 
     * @param {Array<string>} [targetdata] 
     * @param {string} [priorConversation] 
     * @param {StartquestionansweringwithaudioquestionRequest} [startquestionansweringwithaudioquestionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public startquestionansweringwithaudioquestion(componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, startquestionansweringwithaudioquestionRequest?: StartquestionansweringwithaudioquestionRequest, options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).startquestionansweringwithaudioquestion(componentlist, language, targetdata, priorConversation, startquestionansweringwithaudioquestionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a simple HTML form for starting a question answering process with an audio question
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public startquestionansweringwithaudioquestion1(options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).startquestionansweringwithaudioquestion1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a simple HTML input form for starting a question answering process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public startquestionansweringwithtextquestion1(options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).startquestionansweringwithtextquestion1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parameters are supplied via JSON. Only the question parameter is required. Examples: {\"question\": \"What is the capital of Germany?\"}, {\"question\": \"Person born in France?\"}
     * @summary Start a process directly with a textual question
     * @param {string} question 
     * @param {RequestQuestionAnsweringProcess} requestQuestionAnsweringProcess 
     * @param {Array<string>} [componentlist] 
     * @param {string} [language] 
     * @param {Array<string>} [targetdata] 
     * @param {string} [priorConversation] 
     * @param {AdditionalTriples} [additionaltriples] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof QanaryQuestionAnsweringControllerApi
     */
    public startquestionansweringwithtextquestion11(question: string, requestQuestionAnsweringProcess: RequestQuestionAnsweringProcess, componentlist?: Array<string>, language?: string, targetdata?: Array<string>, priorConversation?: string, additionaltriples?: AdditionalTriples, options?: AxiosRequestConfig) {
        return QanaryQuestionAnsweringControllerApiFp(this.configuration).startquestionansweringwithtextquestion11(question, requestQuestionAnsweringProcess, componentlist, language, targetdata, priorConversation, additionaltriples, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QanaryQuestionControllerApi - axios parameter creator
 * @export
 */
export const QanaryQuestionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Start a question answering process with an audio file via synchronous POST and return the URL of the created question. Requires an audio file.
         * @summary Synchronous call o sart a QA process wih an audio file
         * @param {StartquestionansweringwithaudioquestionRequest} [startquestionansweringwithaudioquestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAudioQuestion: async (startquestionansweringwithaudioquestionRequest?: StartquestionansweringwithaudioquestionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/question_audio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startquestionansweringwithaudioquestionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a question answering process via synchronous POST request and return the URL of the created question. Requires a question string.
         * @summary Synchronous call o sart a QA process
         * @param {string} question 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestion: async (question: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'question' is not null or undefined
            assertParamExists('createQuestion', 'question', question)
            const localVarPath = `/question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (question !== undefined) {
                localVarQueryParameter['question'] = question;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (Not yet implemented) Requires the question ID.
         * @summary Delete a given question
         * @param {string} questionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion: async (questionid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionid' is not null or undefined
            assertParamExists('deleteQuestion', 'questionid', questionid)
            const localVarPath = `/question/{questionid}`
                .replace(`{${"questionid"}}`, encodeURIComponent(String(questionid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specify the question with its ID. Example: \"/question/1\"
         * @summary Return links to all information of a given question
         * @param {string} questionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestion: async (questionid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionid' is not null or undefined
            assertParamExists('getQuestion', 'questionid', questionid)
            const localVarPath = `/question/{questionid}`
                .replace(`{${"questionid"}}`, encodeURIComponent(String(questionid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the ID of the question. Example: \"/question/1/raw\"
         * @summary Return raw data for a given question
         * @param {string} questionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionRawData: async (questionid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionid' is not null or undefined
            assertParamExists('getQuestionRawData', 'questionid', questionid)
            const localVarPath = `/question/{questionid}/raw`
                .replace(`{${"questionid"}}`, encodeURIComponent(String(questionid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * No parameters are required
         * @summary Reurn links to all questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/question/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (Not yet implemented) Requires the URL of the question.
         * @summary Fetch the processing status of a given question
         * @param {string} questionuri 
         * @param {'application/json'} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfQuestion: async (questionuri: string, accept?: 'application/json', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionuri' is not null or undefined
            assertParamExists('getStatusOfQuestion', 'questionuri', questionuri)
            const localVarPath = `/question/{question}/status`
                .replace(`{${"questionuri"}}`, encodeURIComponent(String(questionuri)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanaryQuestionControllerApi - functional programming interface
 * @export
 */
export const QanaryQuestionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanaryQuestionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Start a question answering process with an audio file via synchronous POST and return the URL of the created question. Requires an audio file.
         * @summary Synchronous call o sart a QA process wih an audio file
         * @param {StartquestionansweringwithaudioquestionRequest} [startquestionansweringwithaudioquestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAudioQuestion(startquestionansweringwithaudioquestionRequest?: StartquestionansweringwithaudioquestionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAudioQuestion(startquestionansweringwithaudioquestionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a question answering process via synchronous POST request and return the URL of the created question. Requires a question string.
         * @summary Synchronous call o sart a QA process
         * @param {string} question 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestion(question: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestion(question, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (Not yet implemented) Requires the question ID.
         * @summary Delete a given question
         * @param {string} questionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestion(questionid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuestion(questionid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Specify the question with its ID. Example: \"/question/1\"
         * @summary Return links to all information of a given question
         * @param {string} questionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestion(questionid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QanaryQuestionInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestion(questionid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requires the ID of the question. Example: \"/question/1/raw\"
         * @summary Return raw data for a given question
         * @param {string} questionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionRawData(questionid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionRawData(questionid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * No parameters are required
         * @summary Reurn links to all questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QanaryAvailableQuestions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (Not yet implemented) Requires the URL of the question.
         * @summary Fetch the processing status of a given question
         * @param {string} questionuri 
         * @param {'application/json'} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusOfQuestion(questionuri: string, accept?: 'application/json', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusOfQuestion(questionuri, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanaryQuestionControllerApi - factory interface
 * @export
 */
export const QanaryQuestionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanaryQuestionControllerApiFp(configuration)
    return {
        /**
         * Start a question answering process with an audio file via synchronous POST and return the URL of the created question. Requires an audio file.
         * @summary Synchronous call o sart a QA process wih an audio file
         * @param {StartquestionansweringwithaudioquestionRequest} [startquestionansweringwithaudioquestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAudioQuestion(startquestionansweringwithaudioquestionRequest?: StartquestionansweringwithaudioquestionRequest, options?: any): AxiosPromise<object> {
            return localVarFp.createAudioQuestion(startquestionansweringwithaudioquestionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a question answering process via synchronous POST request and return the URL of the created question. Requires a question string.
         * @summary Synchronous call o sart a QA process
         * @param {string} question 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestion(question: string, options?: any): AxiosPromise<object> {
            return localVarFp.createQuestion(question, options).then((request) => request(axios, basePath));
        },
        /**
         * (Not yet implemented) Requires the question ID.
         * @summary Delete a given question
         * @param {string} questionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion(questionid: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteQuestion(questionid, options).then((request) => request(axios, basePath));
        },
        /**
         * Specify the question with its ID. Example: \"/question/1\"
         * @summary Return links to all information of a given question
         * @param {string} questionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestion(questionid: string, options?: any): AxiosPromise<QanaryQuestionInformation> {
            return localVarFp.getQuestion(questionid, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires the ID of the question. Example: \"/question/1/raw\"
         * @summary Return raw data for a given question
         * @param {string} questionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionRawData(questionid: string, options?: any): AxiosPromise<File> {
            return localVarFp.getQuestionRawData(questionid, options).then((request) => request(axios, basePath));
        },
        /**
         * No parameters are required
         * @summary Reurn links to all questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestions(options?: any): AxiosPromise<QanaryAvailableQuestions> {
            return localVarFp.getQuestions(options).then((request) => request(axios, basePath));
        },
        /**
         * (Not yet implemented) Requires the URL of the question.
         * @summary Fetch the processing status of a given question
         * @param {string} questionuri 
         * @param {'application/json'} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfQuestion(questionuri: string, accept?: 'application/json', options?: any): AxiosPromise<string> {
            return localVarFp.getStatusOfQuestion(questionuri, accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanaryQuestionControllerApi - object-oriented interface
 * @export
 * @class QanaryQuestionControllerApi
 * @extends {BaseAPI}
 */
export class QanaryQuestionControllerApi extends BaseAPI {
    /**
     * Start a question answering process with an audio file via synchronous POST and return the URL of the created question. Requires an audio file.
     * @summary Synchronous call o sart a QA process wih an audio file
     * @param {StartquestionansweringwithaudioquestionRequest} [startquestionansweringwithaudioquestionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionControllerApi
     */
    public createAudioQuestion(startquestionansweringwithaudioquestionRequest?: StartquestionansweringwithaudioquestionRequest, options?: AxiosRequestConfig) {
        return QanaryQuestionControllerApiFp(this.configuration).createAudioQuestion(startquestionansweringwithaudioquestionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a question answering process via synchronous POST request and return the URL of the created question. Requires a question string.
     * @summary Synchronous call o sart a QA process
     * @param {string} question 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionControllerApi
     */
    public createQuestion(question: string, options?: AxiosRequestConfig) {
        return QanaryQuestionControllerApiFp(this.configuration).createQuestion(question, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (Not yet implemented) Requires the question ID.
     * @summary Delete a given question
     * @param {string} questionid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionControllerApi
     */
    public deleteQuestion(questionid: string, options?: AxiosRequestConfig) {
        return QanaryQuestionControllerApiFp(this.configuration).deleteQuestion(questionid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specify the question with its ID. Example: \"/question/1\"
     * @summary Return links to all information of a given question
     * @param {string} questionid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionControllerApi
     */
    public getQuestion(questionid: string, options?: AxiosRequestConfig) {
        return QanaryQuestionControllerApiFp(this.configuration).getQuestion(questionid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires the ID of the question. Example: \"/question/1/raw\"
     * @summary Return raw data for a given question
     * @param {string} questionid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionControllerApi
     */
    public getQuestionRawData(questionid: string, options?: AxiosRequestConfig) {
        return QanaryQuestionControllerApiFp(this.configuration).getQuestionRawData(questionid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * No parameters are required
     * @summary Reurn links to all questions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionControllerApi
     */
    public getQuestions(options?: AxiosRequestConfig) {
        return QanaryQuestionControllerApiFp(this.configuration).getQuestions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (Not yet implemented) Requires the URL of the question.
     * @summary Fetch the processing status of a given question
     * @param {string} questionuri 
     * @param {'application/json'} [accept] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanaryQuestionControllerApi
     */
    public getStatusOfQuestion(questionuri: string, accept?: 'application/json', options?: AxiosRequestConfig) {
        return QanaryQuestionControllerApiFp(this.configuration).getStatusOfQuestion(questionuri, accept, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QanarySparqlProtocolControllerApi - axios parameter creator
 * @export
 */
export const QanarySparqlProtocolControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTriplestoreConnection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checktriplestoreconnection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [accept] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparqlAsXML1: async (accept?: string, query?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sparql`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (accept != null) {
                localVarHeaderParameter['accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanarySparqlProtocolControllerApi - functional programming interface
 * @export
 */
export const QanarySparqlProtocolControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanarySparqlProtocolControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkTriplestoreConnection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkTriplestoreConnection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [accept] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSparqlAsXML1(accept?: string, query?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSparqlAsXML1(accept, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanarySparqlProtocolControllerApi - factory interface
 * @export
 */
export const QanarySparqlProtocolControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanarySparqlProtocolControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTriplestoreConnection(options?: any): AxiosPromise<string> {
            return localVarFp.checkTriplestoreConnection(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [accept] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSparqlAsXML1(accept?: string, query?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getSparqlAsXML1(accept, query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanarySparqlProtocolControllerApi - object-oriented interface
 * @export
 * @class QanarySparqlProtocolControllerApi
 * @extends {BaseAPI}
 */
export class QanarySparqlProtocolControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanarySparqlProtocolControllerApi
     */
    public checkTriplestoreConnection(options?: AxiosRequestConfig) {
        return QanarySparqlProtocolControllerApiFp(this.configuration).checkTriplestoreConnection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [accept] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanarySparqlProtocolControllerApi
     */
    public getSparqlAsXML1(accept?: string, query?: string, options?: AxiosRequestConfig) {
        return QanarySparqlProtocolControllerApiFp(this.configuration).getSparqlAsXML1(accept, query, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QanarySpringBootAdminCompatibilityRedirectControllerApi - axios parameter creator
 * @export
 */
export const QanarySpringBootAdminCompatibilityRedirectControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationOfOldSpringBootAdminClient: async (body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('registrationOfOldSpringBootAdminClient', 'body', body)
            const localVarPath = `/api/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QanarySpringBootAdminCompatibilityRedirectControllerApi - functional programming interface
 * @export
 */
export const QanarySpringBootAdminCompatibilityRedirectControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QanarySpringBootAdminCompatibilityRedirectControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registrationOfOldSpringBootAdminClient(body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Result>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registrationOfOldSpringBootAdminClient(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QanarySpringBootAdminCompatibilityRedirectControllerApi - factory interface
 * @export
 */
export const QanarySpringBootAdminCompatibilityRedirectControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QanarySpringBootAdminCompatibilityRedirectControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationOfOldSpringBootAdminClient(body: string, options?: any): AxiosPromise<Result> {
            return localVarFp.registrationOfOldSpringBootAdminClient(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QanarySpringBootAdminCompatibilityRedirectControllerApi - object-oriented interface
 * @export
 * @class QanarySpringBootAdminCompatibilityRedirectControllerApi
 * @extends {BaseAPI}
 */
export class QanarySpringBootAdminCompatibilityRedirectControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QanarySpringBootAdminCompatibilityRedirectControllerApi
     */
    public registrationOfOldSpringBootAdminClient(body: string, options?: AxiosRequestConfig) {
        return QanarySpringBootAdminCompatibilityRedirectControllerApiFp(this.configuration).registrationOfOldSpringBootAdminClient(body, options).then((request) => request(this.axios, this.basePath));
    }
}


